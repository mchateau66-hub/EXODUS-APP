# .github/workflows/pr-guardian.yml
name: PR Guardian — Security Checklist

on:
  pull_request:
    branches: [main, staging]
    types: [opened, edited, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-guardian-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  pr-guardian:
    name: pr-guardian
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Validate Security Checklist
        id: check
        env:
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_LABELS: ${{ toJson(github.event.pull_request.labels.*.name) }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import os, re, sys, json, unicodedata, pathlib

          body = os.environ.get("PR_BODY") or ""
          author = (os.environ.get("PR_AUTHOR") or "").strip()
          labels_json = os.environ.get("PR_LABELS") or "[]"
          try:
            labels = json.loads(labels_json)
          except Exception:
            labels = []

          marker = "<!-- pr-guardian -->"
          skip_marker_pattern = r"pr-guardian\s*:\s*skip"

          def write_output(**kwargs):
            out = os.environ.get("GITHUB_OUTPUT")
            if not out:
              return
            with open(out, "a", encoding="utf-8") as f:
              for k, v in kwargs.items():
                f.write(f"{k}={v}\n")

          def normalize(s: str) -> str:
            s = s.replace("\r", "")
            s = s.replace("•", "- ")
            s = s.replace("–", "-").replace("—", "-")
            s = "".join(c for c in unicodedata.normalize("NFKD", s) if not unicodedata.combining(c))
            return s

          norm = normalize(body)
          pathlib.Path("pr_body_norm.md").write_text(norm, encoding="utf-8")

          # ---- SKIP conditions ----
          labelset = {str(l).lower() for l in (labels or [])}

          if author.lower() == "dependabot[bot]":
            report = [
              marker,
              "### PR Guardian Report",
              "",
              "Skipped ✅ (Dependabot PR).",
              "",
              "> This repository enforces a security checklist on human-made PRs only.",
              "",
            ]
            pathlib.Path("report.md").write_text("\n".join(report) + "\n", encoding="utf-8")
            write_output(result="skip")
            sys.exit(0)

          if re.search(skip_marker_pattern, norm, flags=re.IGNORECASE):
            report = [
              marker,
              "### PR Guardian Report",
              "",
              "Skipped ✅ (`<!-- pr-guardian:skip -->` found in PR body).",
              "",
            ]
            pathlib.Path("report.md").write_text("\n".join(report) + "\n", encoding="utf-8")
            write_output(result="skip")
            sys.exit(0)

          if "skip-security-checklist" in labelset or "pr-guardian-skip" in labelset:
            report = [
              marker,
              "### PR Guardian Report",
              "",
              "Skipped ✅ (label detected: `skip-security-checklist` / `pr-guardian-skip`).",
              "",
            ]
            pathlib.Path("report.md").write_text("\n".join(report) + "\n", encoding="utf-8")
            write_output(result="skip")
            sys.exit(0)

          # ---- Required checklist items ----
          required = [
            ("Monetisation", r"monetisation"),
            ("Entitlements", r"entitlements"),
            ("Stripe", r"stripe"),
            ("CSP", r"\bcsp\b|content\s*security\s*policy"),
            ("RateLimit", r"rate\s*-?\s*limit|ratelimit"),
            ("Health", r"\bhealth\b|\bready\b|\breadiness\b"),
            ("PII-Guard", r"pii\s*-?\s*guard"),
            ("E2E", r"\be2e\b"),
            ("Security audit", r"security\s*audit|audit\s*securite|audit\s*securite"),
          ]

          def ticked_line_regex(keyword_pattern: str) -> re.Pattern:
            # Matches "- [x] ... <keyword>"
            return re.compile(
              r"^\s*[-*]\s*\[\s*[xX]\s*\]\s*.*(" + keyword_pattern + r")",
              flags=re.IGNORECASE | re.MULTILINE,
            )

          if not norm.strip():
            missing = [k for (k, _) in required]
            report = [
              marker,
              "### PR Guardian Report",
              "",
              "PR body is empty.",
              "",
              "Missing items (tick the boxes in PR template):",
              *[f"- [ ] {m}" for m in missing],
              "",
              "Please edit the PR description and check the corresponding boxes (`[x]`).",
              "",
            ]
            pathlib.Path("report.md").write_text("\n".join(report) + "\n", encoding="utf-8")
            write_output(result="fail")
            print("PR body is empty", file=sys.stderr)
            sys.exit(1)

          missing = []
          for key, kw in required:
            if not ticked_line_regex(kw).search(norm):
              missing.append(key)

          report = [marker, "### PR Guardian Report", ""]
          report.append(f"Checked {len(required)} required security checkboxes.")
          report.append("")

          if not missing:
            report.append("All required items are ticked ✅")
            pathlib.Path("report.md").write_text("\n".join(report) + "\n", encoding="utf-8")
            write_output(result="pass")
            sys.exit(0)

          report.append("Missing items (tick the boxes in PR template):")
          report.extend([f"- [ ] {m}" for m in missing])
          report.append("")
          report.append("Please edit the PR description and check the corresponding boxes (`[x]`).")
          report.append("")
          pathlib.Path("report.md").write_text("\n".join(report) + "\n", encoding="utf-8")

          write_output(result="fail")
          print("Missing required checklist items: " + ", ".join(missing), file=sys.stderr)
          sys.exit(1)
          PY

      - name: Add summary
        if: always()
        run: |
          echo "### PR Guardian" >> "$GITHUB_STEP_SUMMARY"
          if [ -f report.md ]; then
            cat report.md >> "$GITHUB_STEP_SUMMARY"
          else
            echo "(no report)" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Comment on PR — create or update (only when needed)
        if: always()
        uses: actions/github-script@v7
        env:
          RESULT: ${{ steps.check.outputs.result }}
        with:
          script: |
            const fs = require('fs');

            const marker = '<!-- pr-guardian -->';
            const result = process.env.RESULT || 'unknown';
            const report = fs.existsSync('report.md')
              ? fs.readFileSync('report.md', 'utf8')
              : `${marker}\n### PR Guardian Report\n\n(no report)`;

            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number,
              per_page: 100,
            });

            const existing = comments.find(c => typeof c.body === 'string' && c.body.includes(marker));

            // If FAIL -> ensure there's a comment (create or update)
            if (result === 'fail') {
              if (existing) {
                await github.rest.issues.updateComment({
                  owner, repo, comment_id: existing.id, body: report,
                });
              } else {
                await github.rest.issues.createComment({
                  owner, repo, issue_number, body: report,
                });
              }
              return;
            }

            // If PASS/SKIP -> only update if a previous comment exists (avoid spamming)
            if (existing) {
              await github.rest.issues.updateComment({
                owner, repo, comment_id: existing.id, body: report,
              });
            }
